/**
 * Slug for anchor links: lowercase, spaces to hyphens, strip parens content for clean URLs.
 */
export function slugify(title: string): string {
  return title
    .replace(/\s*\([^)]*\)\s*/g, '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '');
}

export type ConceptEntry = {
  title: string;
  body: string;
  example?: string;
  exampleCode?: string;
  exampleCodeLang?: string;
  references?: readonly { label: string; url: string }[];
};

export const FRONTEND_CONCEPTS: readonly ConceptEntry[] = [
  { title: 'Hydration', body: 'Hydration is the process where client-side JavaScript attaches event listeners and state to HTML that was rendered on the server, making the page interactive without re-rendering the entire DOM. The goal is to reuse existing markup to reduce load time while enabling full client behavior.' },
  { title: 'Partial hydration', body: 'Partial hydration delays or skips hydrating parts of the DOM that are not immediately interactive, reducing JavaScript execution cost. Only critical or user-interacted components are hydrated, improving startup performance.' },
  { title: 'Islands architecture', body: 'Islands architecture renders most of the page as static HTML while isolating interactive components ("islands") that hydrate independently. This minimizes JavaScript usage and scales interactivity more efficiently.', references: [{ label: 'Islands Architecture (islandsarchitecture.com)', url: 'https://islandsarchitecture.com/' }] },
  { title: 'Streaming SSR', body: 'Streaming SSR sends HTML to the browser incrementally as it\'s generated, allowing the browser to begin parsing and rendering before the full response is complete. This improves time-to-first-paint and perceived performance.' },
  { title: 'Concurrent rendering', body: 'Concurrent rendering allows rendering work to be paused, resumed, or abandoned to keep the UI responsive. It prioritizes user interactions over non-urgent updates.', references: [{ label: 'React: Concurrent rendering', url: 'https://react.dev/learn/react-compiler#concurrent-rendering' }] },
  { title: 'Time slicing', body: 'Time slicing breaks rendering work into small chunks so the browser can handle user input between them. This prevents long blocking renders that cause jank.' },
  { title: 'Reconciliation algorithm', body: 'The reconciliation algorithm determines how UI state changes translate into DOM updates by comparing previous and next render trees. Efficient reconciliation minimizes unnecessary DOM mutations.', exampleCode: '// Keys tell React which items are stable across re-renders\nconst list = items.map(item => (\n  <li key={item.id}>{item.name}</li>\n));\n// Without keys, reordering causes unnecessary DOM mutations.', exampleCodeLang: 'tsx', references: [{ label: 'React: Preserving and resetting state', url: 'https://react.dev/learn/preserving-and-resetting-state' }] },
  { title: 'Fiber architecture', body: 'Fiber is a reimplementation of the reconciliation engine that represents rendering work as a linked data structure, enabling interruption, prioritization, and concurrency.', references: [{ label: 'Inside Fiber (indepth.dev)', url: 'https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react' }] },
  { title: 'Virtual DOM diffing complexity', body: 'Virtual DOM diffing typically runs in linear time by comparing trees level-by-level and assuming stable structure. Keys help avoid expensive reordering operations.', example: 'O(n) diff assumes tree shape is similar; reordering a list without keys can cause O(n²) behavior because the algorithm may match by position instead of identity.' },
  { title: 'Structural sharing', body: 'Structural sharing reuses unchanged parts of data structures between versions, reducing memory usage and enabling cheap comparisons. It is common in immutable state systems.', references: [{ label: 'Immer', url: 'https://immerjs.github.io/immer/' }, { label: 'Immutable.js', url: 'https://immutable-js.com/' }] },
  { title: 'Immutable data patterns', body: 'Immutable data patterns avoid mutating existing objects and instead create new versions. This simplifies change detection, undo/redo, and concurrency safety.', exampleCode: '// Instead of mutating:\n// state.items.push(newItem);\n// Do:\nsetState({ ...state, items: [...state.items, newItem] });', exampleCodeLang: 'ts' },
  { title: 'Referential equality', body: 'Referential equality checks whether two references point to the same object in memory. Many optimizations rely on stable references to skip work.' },
  { title: 'Memoization pitfalls', body: 'Memoization can backfire if dependencies are unstable or if memory usage grows unchecked. Incorrect dependency tracking can cause stale or incorrect results.', example: 'React compares dependency arrays by reference (Object.is). If you put an object literal in the deps, e.g. { id: b }, a new object is created on every render, so the deps are always "different" and useMemo recomputes every time—giving you no benefit and extra overhead.', exampleCode: '// BAD: new object every render → memo never helps\nuseMemo(() => compute(a), [a, { id: b }]);\n// GOOD: stable deps\nuseMemo(() => compute(a), [a, b]);', exampleCodeLang: 'ts' },
  { title: 'Stale closure problem', body: 'Stale closures occur when a function captures variables from its surrounding scope at the time it was created, and later runs with those same (now outdated) values instead of the current ones. In JavaScript, a closure "closes over" the variables it references; it keeps the binding to whatever value they had when the function was created. In React, each render gets its own `count`, `props`, etc. If you start a timer or subscription in an effect with an empty dependency array, the callback you pass closes over the state from that first render only. When the timer fires later, it still sees the old value, so updates like setCount(count + 1) repeatedly apply to the same stale number.', example: 'Step by step: (1) First render: count is 0. The effect runs once and sets an interval; the callback is "setCount(0 + 1)". (2) One second later the callback runs and sets count to 1. React re-renders with count = 1. (3) The effect has deps [], so it does not run again—the same interval is still active. That interval\'s callback was created in the first render and still closes over count = 0. (4) Every second the callback runs setCount(0 + 1) again, so you keep setting 1 and the display never goes to 2. The closure is "stale" because it\'s holding on to the old count. Fix: use the functional form setCount(c => c + 1) so you always use the latest state, or include count in the effect deps so the effect (and the interval callback) are recreated when count changes.', exampleCode: 'function Counter() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1); // Always sees initial 0 → count stuck at 1\n    }, 1000);\n    return () => clearInterval(id);\n  }, []); // Missing count in deps\n  return <span>{count}</span>;\n}\n// Fix 1: functional update — no closure over count\nsetCount((c) => c + 1);\n// Fix 2: add count to deps — effect and interval recreated when count changes', exampleCodeLang: 'tsx', references: [{ label: 'React: Fixing stale closure (useEffect)', url: 'https://react.dev/learn/synchronizing-with-effects#each-render-has-its-own-effects' }] },
  { title: 'Event loop (macro vs microtasks)', body: 'The event loop processes macrotasks (timers, I/O) and microtasks (Promises) in separate queues, with microtasks always running before rendering and the next macrotask. Understanding it is important because it determines the order in which your async code runs: microtasks (e.g. Promise.then, queueMicrotask) always run to completion before the next macrotask (setTimeout, I/O, UI events), and before the browser paints. That explains why "1, 4, 3, 2" happens in the classic example—and why long synchronous work or a long chain of microtasks can block the main thread, delay input handling, and cause jank. When debugging timing bugs, race conditions, or "why did my callback run after X?", the event loop model tells you what runs when.', example: 'Without this model, setTimeout(fn, 0) and Promise.resolve().then(fn) look similar ("run later"), but they are scheduled differently: the microtask runs before the next render and before any pending timeouts. That affects when state updates appear on screen, when network responses are processed relative to user clicks, and why heavy work in a .then() can freeze the UI until it finishes.', exampleCode: 'console.log(1);\nsetTimeout(() => console.log(2), 0);\nPromise.resolve().then(() => console.log(3));\nconsole.log(4);\n// Output: 1, 4, 3, 2', exampleCodeLang: 'js' },
  { title: 'Task starvation', body: 'Task starvation occurs when high-priority or frequent tasks prevent lower-priority tasks from ever running, leading to delayed work or frozen UI.' },
  { title: 'Layout thrashing', body: 'Layout thrashing happens when reads and writes to layout-dependent properties are interleaved, forcing repeated synchronous reflows and hurting performance.', exampleCode: '// BAD: read, write, read, write → one reflow per element\nfor (const el of elements) {\n  const h = el.offsetHeight; // read (reflow)\n  el.style.height = h + 10 + "px"; // write\n}\n\n// BETTER: batch all reads, then all writes → minimal reflows\nconst heights = elements.map((el) => el.offsetHeight);\nelements.forEach((el, i) => {\n  el.style.height = heights[i] + 10 + "px";\n});', exampleCodeLang: 'js', references: [{ label: 'Avoid large, complex layouts (web.dev)', url: 'https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/' }] },
  { title: 'Critical rendering path', body: 'The critical rendering path is the sequence of steps required to convert HTML, CSS, and JS into pixels. Shortening it improves initial render speed.', references: [{ label: 'Critical rendering path (web.dev)', url: 'https://web.dev/critical-rendering-path/' }] },
  { title: 'Render blocking resources', body: 'Render blocking resources, such as synchronous CSS or JS, delay painting until they are loaded and executed. Optimizing or deferring them improves performance.' },
  { title: 'Tree shaking internals', body: 'Tree shaking removes unused exports by analyzing static module graphs at build time. It relies on ES module semantics and side-effect detection.' },
  { title: 'Code splitting strategies', body: 'Code splitting divides bundles into smaller chunks loaded on demand. Strategies include route-based, component-based, and interaction-based splitting.' },
  { title: 'Dynamic import chunking', body: 'Dynamic imports create separate chunks that load asynchronously. Chunk boundaries affect caching, waterfall behavior, and performance. Advantages: smaller initial bundle and faster time-to-interactive, since heavy or route-specific code is deferred; better long-term caching because changing one feature only invalidates its chunk; and users who never visit a feature never download it. Disadvantages: the first time a chunk is needed there is a network request and a delay before the code runs (waterfall), which can cause a loading flash or delayed interactivity; over-splitting creates many small requests and can increase total latency; and shared dependencies may be duplicated across chunks or require careful configuration to avoid loading the same library multiple times.', example: 'Preload or prefetch key chunks (e.g. for the next likely route) to hide latency; keep critical path in the main bundle and chunk by route or heavy component; monitor chunk sizes and request count so you don’t trade one bottleneck for another.', exampleCode: '// Chunk loaded when this runs\nconst Editor = lazy(() => import("./Editor"));', exampleCodeLang: 'ts' },
  { title: 'Module federation', body: 'Module federation allows multiple builds to share runtime-loaded modules, enabling independent deployment of micro-frontends without duplication.', references: [{ label: 'Module Federation (webpack)', url: 'https://module-federation.io/' }] },
  { title: 'Shadow DOM', body: 'Shadow DOM provides DOM encapsulation, preventing styles and structure from leaking in or out. It enables reusable, isolated components.', example: 'Use Shadow DOM when you need style or DOM isolation: (1) Building Web Components or a design system that must look the same regardless of host page CSS. (2) Embedding widgets (e.g. chat, video player, payment form) that should not be affected by global styles or accidentally affect the page. (3) Third-party or user-generated content where you want to scope styles so they don’t clash with the app. (4) Reusable UI that will be dropped into many sites and you can’t control their stylesheets. Avoid it when you’re fully in control of the page and want shared theming, or when you need the inner DOM to be easily styled from outside (e.g. with utility classes or CSS variables).', exampleCode: '// Page has: p { color: blue; } globally.\n// Without shadow: your component\'s <p> would turn blue (page CSS wins).\n\nconst host = document.getElementById("host");\nconst shadow = host.attachShadow({ mode: "open" });\nshadow.innerHTML = `\n  <style>p { color: red; }</style>\n  <p>I stay red</p>\n`;\n// Benefit: the shadow\'s <p> is only styled by the <style> inside the shadow.\n// Page\'s "p { color: blue }" does not apply here; our "p { color: red }" does not affect the rest of the page.', exampleCodeLang: 'js', references: [{ label: 'MDN: Using shadow DOM', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM' }] },
  { title: 'Custom Elements lifecycle', body: 'Custom Elements define lifecycle callbacks such as connectedCallback and disconnectedCallback, allowing logic to run when elements are attached or removed.', exampleCode: 'class MyEl extends HTMLElement {\n  connectedCallback() { /* added to DOM */ }\n  disconnectedCallback() { /* removed; clean up */ }\n  attributeChangedCallback() { /* attr change */ }\n}\ncustomElements.define("my-el", MyEl);', exampleCodeLang: 'js', references: [{ label: 'MDN: Custom Elements', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements' }] },
  { title: 'Web Components interoperability', body: 'Web Components interoperate across frameworks because they rely on browser standards. Frameworks must handle event and property mapping carefully.' },
  { title: 'Web Workers vs Service Workers', body: 'Web Workers run background scripts for computation, while Service Workers act as network proxies and lifecycle-managed offline handlers.', example: 'Web Worker: offload CPU-heavy work (parsing, crypto, image processing) so the main thread stays responsive. Service Worker: intercept fetch requests to cache responses, serve offline, or rewrite URLs; runs independently of any tab.', exampleCode: '// === Web Worker (computation off main thread) ===\n// main.js\nconst worker = new Worker("/worker.js");\nworker.postMessage({ data: bigArray });\nworker.onmessage = (e) => console.log("Result:", e.data);\n\n// worker.js\nself.onmessage = (e) => {\n  const result = heavyComputation(e.data.data);\n  self.postMessage(result);\n};\n\n// === Service Worker (network proxy / offline) ===\n// register\nnavigator.serviceWorker.register("/sw.js");\n// sw.js\nself.addEventListener("fetch", (event) => {\n  event.respondWith(\n    caches.match(event.request).then((cached) => cached || fetch(event.request))\n  );\n});', exampleCodeLang: 'js', references: [{ label: 'MDN: Web Workers API', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API' }, { label: 'MDN: Service Worker API', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API' }] },
  { title: 'SharedArrayBuffer', body: 'SharedArrayBuffer enables shared memory between threads, allowing true parallelism. It requires cross-origin isolation for security reasons.', references: [{ label: 'MDN: SharedArrayBuffer', url: 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer' }, { label: 'Cross-origin isolation', url: 'https://web.dev/cross-origin-isolation-guide/' }] },
  { title: 'Transferable objects', body: 'Transferable objects move ownership of memory between threads without copying, enabling fast data transfer between workers.' },
  { title: 'OffscreenCanvas', body: 'OffscreenCanvas allows rendering to occur in a worker thread, offloading graphics work from the main thread.', references: [{ label: 'MDN: OffscreenCanvas', url: 'https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas' }] },
  { title: 'WebAssembly integration', body: 'WebAssembly integrates low-level, high-performance code into web apps, often used for compute-heavy tasks while JS handles orchestration.', references: [{ label: 'MDN: WebAssembly', url: 'https://developer.mozilla.org/en-US/docs/WebAssembly' }] },
  { title: 'Browser compositing layers', body: 'Compositing layers separate rendering into independently composited surfaces, enabling GPU-accelerated transforms and animations.' },
  { title: 'Paint vs composite vs layout', body: 'Layout calculates geometry, paint fills pixels, and composite assembles layers. Each stage has different performance costs.', references: [{ label: 'Rendering performance (web.dev)', url: 'https://web.dev/rendering-performance/' }] },
  { title: 'GPU acceleration in CSS', body: 'GPU acceleration offloads transforms and opacity changes to the GPU, improving animation smoothness when used correctly.', example: 'Promoting a layer: transform: translateZ(0) or will-change: transform. Avoid overusing will-change (memory cost).' },
  { title: 'CSS containment', body: 'CSS containment limits layout, paint, or style scope of an element, reducing rendering work and improving performance.', exampleCode: '/* Isolate layout/paint so descendants don’t affect outside */\n.card { contain: layout paint; }', exampleCodeLang: 'css', references: [{ label: 'MDN: CSS containment', url: 'https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment' }] },
  { title: 'Subpixel rendering', body: 'Subpixel rendering improves text sharpness by leveraging RGB subpixels, but can be affected by transforms and compositing.' },
  { title: 'IntersectionObserver internals', body: 'IntersectionObserver batches visibility calculations asynchronously, avoiding costly scroll handlers and synchronous layout reads.', exampleCode: 'const observer = new IntersectionObserver((entries) => {\n  entries.forEach(e => {\n    if (e.isIntersecting) loadLazyContent(e.target);\n  });\n}, { rootMargin: "50px" });\ndocument.querySelectorAll(".lazy").forEach(el => observer.observe(el));', exampleCodeLang: 'js', references: [{ label: 'MDN: IntersectionObserver', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API' }] },
  { title: 'ResizeObserver loop limits', body: 'ResizeObserver detects element size changes but enforces loop limits to prevent infinite resize-triggered feedback cycles.', references: [{ label: 'ResizeObserver: loop limit exceeded', url: 'https://web.dev/articles/resize-observer-loop-limit-exceeded' }] },
  { title: 'MutationObserver cost', body: 'MutationObservers are asynchronous but can be expensive if observing large subtrees or frequent mutations.' },
  { title: 'IndexedDB', body: 'IndexedDB is a transactional, asynchronous key-value database built into browsers for structured client-side storage.', references: [{ label: 'MDN: IndexedDB API', url: 'https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API' }, { label: 'idb (wrapper)', url: 'https://github.com/jakearchibald/idb' }] },
  { title: 'Service Worker lifecycle traps', body: 'Service Worker updates are delayed until old versions are unused, which can cause stale logic if lifecycle rules are misunderstood.', example: 'New SW installs but waits in "waiting"; it only activates when all tabs using the old SW are closed, or skipWaiting() is called during install.', references: [{ label: 'Service Worker lifecycle (web.dev)', url: 'https://web.dev/articles/service-worker-lifecycle' }] },
  { title: 'Cache invalidation strategies', body: 'Cache invalidation ensures users receive fresh content through versioning, revalidation, or explicit eviction.' },
  { title: 'Stale-while-revalidate', body: 'Stale-while-revalidate serves cached content immediately while fetching updates in the background for future requests.', example: 'Cache-Control: max-age=60, stale-while-revalidate=300 — serve from cache for 60s, then allow stale for 300s while revalidating.' },
  { title: 'ETag vs Cache-Control', body: 'ETags enable validation via conditional requests, while Cache-Control defines freshness rules and caching behavior.', exampleCode: '// Response: ETag: "abc123", Cache-Control: max-age=3600\n// Next request: If-None-Match: "abc123" → 304 Not Modified', exampleCodeLang: 'http', references: [{ label: 'MDN: HTTP caching', url: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching' }] },
  { title: 'HTTP/3 and QUIC', body: 'HTTP/3 runs over QUIC, reducing latency by eliminating head-of-line blocking and improving connection migration.', references: [{ label: 'HTTP/3 (web.dev)', url: 'https://web.dev/articles/http3' }] },
  { title: 'Priority hints', body: 'Priority hints let developers signal resource importance to the browser, improving scheduling of network requests.' },
  { title: 'Preload vs Prefetch vs Preconnect', body: 'Preload fetches critical resources immediately, prefetch loads likely future resources, and preconnect establishes early connections.', exampleCode: '<link rel="preload" href="critical.css" as="style">\n<link rel="prefetch" href="next-page.js">\n<link rel="preconnect" href="https://api.example.com">', exampleCodeLang: 'html', references: [{ label: 'Preload, prefetch (web.dev)', url: 'https://web.dev/articles/preload-critical-assets' }] },
  { title: 'CORS preflight', body: 'CORS preflight requests verify cross-origin permissions before sending certain requests, adding latency when misconfigured.', example: 'Preflight (OPTIONS) is sent when the request uses non-simple methods/headers (e.g. PUT, custom headers). Server must respond with Access-Control-Allow-* that match the actual request.', references: [{ label: 'MDN: CORS', url: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS' }] },
  { title: 'SameSite cookie modes', body: 'SameSite controls when cookies are sent with cross-site requests, helping mitigate CSRF attacks.', exampleCode: 'Set-Cookie: session=abc; SameSite=Lax  // default\nSameSite=Strict  // only same-site\nSameSite=None; Secure  // cross-site (e.g. embeds)', exampleCodeLang: 'http', references: [{ label: 'MDN: SameSite cookies', url: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite' }] },
  { title: 'CSRF vs XSS mitigation', body: 'CSRF mitigation focuses on request authenticity, while XSS mitigation focuses on preventing script injection and execution.' },
  { title: 'Content Security Policy (CSP)', body: 'CSP restricts allowed sources of scripts, styles, and other resources, reducing XSS attack surface.', exampleCode: 'Content-Security-Policy: default-src \'self\'; script-src \'self\' https://trusted.cdn.com;', exampleCodeLang: 'http', references: [{ label: 'MDN: CSP', url: 'https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP' }] },
  { title: 'Trusted Types', body: 'Trusted Types prevent DOM XSS by enforcing safe object creation for dangerous sinks like innerHTML.', exampleCode: '// Policy creates TrustedHTML; innerHTML only accepts it\nconst policy = trustedTypes.createPolicy("default", {\n  createHTML: (input) => DOMPurify.sanitize(input)\n});\nelement.innerHTML = policy.createHTML(userInput);', exampleCodeLang: 'js', references: [{ label: 'web.dev: Trusted Types', url: 'https://web.dev/articles/trusted-types' }] },
  { title: 'DOM clobbering', body: 'DOM clobbering exploits name collisions between DOM elements and JS properties, potentially leading to security issues.', exampleCode: '// If HTML has <form id="x"><input name="y"></form>,\n// then x.y can refer to the input element, clobbering expected JS.', exampleCodeLang: 'html', references: [{ label: 'DOM Clobbering (portswigger)', url: 'https://portswigger.net/research/dom-clobbering-attacks' }] },
  { title: 'Prototype pollution', body: 'Prototype pollution injects properties into object prototypes, potentially altering application behavior globally.', exampleCode: '// Malicious input: __proto__.isAdmin = true\n// Merged into object: obj.isAdmin may become true for all objects.', exampleCodeLang: 'js', references: [{ label: 'Prototype pollution (portswigger)', url: 'https://portswigger.net/web-security/prototype-pollution' }] },
  { title: 'Race conditions in UI state', body: 'Race conditions occur when async state updates resolve out of order, causing inconsistent UI.', exampleCode: '// User clicks "Load A", then "Load B"; response B arrives first.\n// Without cancellation/ignoring stale responses, A overwrites B.\n// Fix: AbortController, request ID, or ignore outdated setState.', exampleCodeLang: 'ts', references: [{ label: 'React: You might not need an effect (race)', url: 'https://react.dev/learn/you-might-not-need-an-effect#fetching-data' }] },
  { title: 'Tearing in concurrent UI', body: 'Tearing happens when different parts of the UI read inconsistent state during concurrent rendering.' },
  { title: 'Scheduler priorities', body: 'Schedulers assign priority levels to tasks, ensuring urgent interactions are handled before background work.' },
  { title: 'Render waterfalls', body: 'Render waterfalls occur when sequential resource dependencies delay rendering. Parallelization reduces them.' },
  { title: 'Suspense boundaries', body: 'Suspense boundaries define loading fallbacks and isolate async rendering delays to specific UI regions.', exampleCode: '<Suspense fallback={<Spinner />}>\n  <LazyComponent />\n</Suspense>', exampleCodeLang: 'tsx', references: [{ label: 'React: Suspense', url: 'https://react.dev/reference/react/Suspense' }] },
  { title: 'Selective hydration', body: 'Selective hydration hydrates components only when needed, often triggered by visibility or interaction.' },
  { title: 'Server components', body: 'Server components render on the server and never ship JS to the client, reducing bundle size and improving performance.', references: [{ label: 'React: Server Components', url: 'https://react.dev/reference/react/use-server' }, { label: 'Next.js: Server Components', url: 'https://nextjs.org/docs/app/building-your-application/rendering/server-components' }] },
  { title: 'Edge rendering', body: 'Edge rendering executes rendering logic close to users geographically, reducing latency.' },
  { title: 'Micro-frontend orchestration', body: 'Micro-frontend orchestration coordinates multiple independently deployed frontend units into a cohesive app.' },
  { title: 'Finite state modeling', body: 'Finite state modeling represents UI behavior as explicit states and transitions, reducing ambiguity and bugs.', references: [{ label: 'XState', url: 'https://statelyai.github.io/xstate/' }, { label: 'Statecharts (statecharts.github.io)', url: 'https://statecharts.github.io/' }] },
  { title: 'Event sourcing in frontend', body: 'Event sourcing stores state changes as a sequence of events, enabling replay and debugging.' },
  { title: 'Optimistic UI rollback strategy', body: 'Optimistic UI updates assume success and roll back state if operations fail, improving perceived responsiveness.', example: 'On submit: update UI immediately, then revert and show error if the request fails.' },
  { title: 'Offline conflict resolution', body: 'Offline conflict resolution reconciles divergent state when connectivity is restored, often using timestamps or merges.' },
  { title: 'CRDT basics for collaboration', body: 'CRDTs are data structures that resolve conflicts automatically, enabling real-time collaboration without central coordination.', references: [{ label: 'Yjs', url: 'https://yjs.dev/' }, { label: 'Automerge', url: 'https://automerge.org/' }] },
  { title: 'WebRTC', body: 'WebRTC enables peer-to-peer audio, video, and data communication directly in browsers.', references: [{ label: 'MDN: WebRTC', url: 'https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API' }] },
  { title: 'Backpressure in streams API', body: 'Backpressure prevents producers from overwhelming consumers by signaling demand through the stream pipeline.' },
  { title: 'AbortController', body: 'AbortController provides a standard way to cancel async operations like fetch requests.', exampleCode: 'const controller = new AbortController();\nfetch(url, { signal: controller.signal })\n  .then(r => r.json())\n  .catch(e => e.name === "AbortError" && "cancelled");\n// Later: controller.abort();', exampleCodeLang: 'js', references: [{ label: 'MDN: AbortController', url: 'https://developer.mozilla.org/en-US/docs/Web/API/AbortController' }] },
  { title: 'Streaming fetch response handling', body: 'Streaming fetch allows incremental consumption of response bodies, reducing memory usage and latency.', exampleCode: 'const res = await fetch(url);\nconst reader = res.body.getReader();\nwhile (true) {\n  const { done, value } = await reader.read();\n  if (done) break;\n  processChunk(value);\n}', exampleCodeLang: 'js' },
  { title: 'Browser memory leak detection', body: 'Memory leak detection involves profiling heap snapshots and tracking retained objects over time.', references: [{ label: 'Chrome DevTools: Memory', url: 'https://developer.chrome.com/docs/devtools/memory-problems/' }] },
  { title: 'Detached DOM nodes', body: 'Detached DOM nodes remain in memory after removal if references persist, causing leaks.', exampleCode: 'const node = document.getElementById("old");\ndocument.body.removeChild(node);\n// If a closure or global still holds `node`, it stays in memory.', exampleCodeLang: 'js' },
  { title: 'Garbage collection timing', body: 'Garbage collection is non-deterministic and can introduce pauses, impacting performance if allocations are excessive.' },
  { title: 'PerformanceObserver API', body: 'PerformanceObserver collects performance metrics asynchronously, enabling real-time monitoring.', references: [{ label: 'MDN: PerformanceObserver', url: 'https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver' }] },
  { title: 'Long tasks API', body: 'The Long Tasks API identifies main-thread tasks exceeding 50ms, helping diagnose jank.' },
  { title: 'First Input Delay (FID)', body: 'FID measures the delay between first user interaction and browser response, reflecting interactivity.', references: [{ label: 'FID (web.dev)', url: 'https://web.dev/articles/fid' }] },
  { title: 'Interaction to Next Paint (INP)', body: 'INP measures responsiveness across all interactions, replacing FID as a more comprehensive metric.', references: [{ label: 'INP (web.dev)', url: 'https://web.dev/articles/inp' }] },
  { title: 'Cumulative Layout Shift (CLS)', body: 'CLS measures unexpected layout movement, impacting visual stability.', references: [{ label: 'CLS (web.dev)', url: 'https://web.dev/articles/cls' }] },
  { title: 'Largest Contentful Paint (LCP)', body: 'LCP measures when the largest visible element finishes rendering, reflecting load performance.', references: [{ label: 'LCP (web.dev)', url: 'https://web.dev/articles/lcp' }] },
  { title: 'Speculative prerendering', body: 'Speculative prerendering loads and renders pages in advance based on predicted navigation.' },
  { title: 'Priority inversion in async code', body: 'Priority inversion occurs when low-priority async work blocks high-priority tasks indirectly.' },
  { title: 'Deterministic rendering', body: 'Deterministic rendering ensures the same inputs always produce the same UI output.' },
  { title: 'Idempotent UI actions', body: 'Idempotent UI actions can be repeated without changing the final result, simplifying retries.' },
  { title: 'Accessibility tree', body: 'The accessibility tree represents semantic UI information exposed to assistive technologies.', references: [{ label: 'MDN: Accessibility tree', url: 'https://developer.mozilla.org/en-US/docs/Glossary/Accessibility_tree' }] },
  { title: 'ARIA live regions internals', body: 'ARIA live regions notify assistive technologies of dynamic content changes asynchronously.', exampleCode: '<div aria-live="polite" aria-atomic="true">\n  {message}\n</div>', exampleCodeLang: 'tsx', references: [{ label: 'MDN: ARIA live regions', url: 'https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions' }] },
  { title: 'Pointer events', body: 'Pointer events unify mouse, touch, and pen input under a single event model.', references: [{ label: 'MDN: Pointer events', url: 'https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events' }] },
];
